{"componentChunkName":"component---src-templates-blog-post-jsx","path":"/2021/how-to-structure-a-golang-cli-project/","result":{"data":{"site":{"siteMetadata":{"title":"Grishy","author":"Sergey Grishin"}},"markdownRemark":{"id":"ac81478d-c84b-5511-8c59-b64fd22fa42b","html":"<p>Недавно я реструктурировал свой <a href=\"https://github.com/madflojo/efs2\">ранний Go проект</a>. Когда я менял структуру, вспомнил, что есть множество рекомендаций по структурированию, но нет единого стандарта для Golang проектов.  </p>\n<p>В других языка программирования, таких как Java, существует стандартная структура проекта, которой большинство программистов следует. В Python используемый фреймворк (Django или Flask) будет определять структуру проекта. Однако, Go находится на этапе, когда сообщество пока не выбрало стандартный подход. </p>\n<p>Однако, есть множество рекомендаций. Но просматривая рекомендации, я понял, что они не полностью подходят для моего проекта.</p>\n<p>В этой статье будет обсуждаться, как я в конечном итоге структурировал свой проект (который в итоге не сильно отличаюется от рекомндаций) и стардартные практики.</p>\n<h2>Сделать код модульным с помощью хорошо разработанных пакетов</h2>\n<p>Прежде всего следует упомянуть, что любой код в приложении, который используется повтороно, должен быть пакетом. О том, как структурировать пакеты и лучшие способы сделать это, достойно отдельно статьи. (У автора оригинальной статьи есть <a href=\"https://go-pkg-structure.dev/\">презентация по этой теме</a>)</p>\n<p>Я хотел бы сказать, что разбиение кода на пакеты содержит не только преимущества от переиспользования кода. С точки зрения структуры проекта это помогает сгруппировать код с общей целью вместе. Это помогает другим находить и менять код, что является важным атрибутом, особенно для проектов с открытым исходным кодом. </p>\n<p>Пакеты также часто упрощают тестирование кода. Изолируя функциональность в пакете, мы можем протестировать эту функциональность с меньшим количеством зависимостей.</p>\n<p>Когда я начинаю новый проект или реструктурирую существующий, обычно в начале записываю различные пакеты, которые мне необходимы. Иногда, я даже создаю базовую структуру пакетов, прежде чем писать код или заниматься рефакторингом.</p>\n<h2>Вынести точку входа из кода приложения</h2>\n<p>Другая хорошая практика, которую я видел в большестве рекомендаций по структуре проекта - это разделение кода приложения и точки входа в программу. Под точкой входа я подрузамеваю <code class=\"language-text\">main()</code> функцию в пакете <code class=\"language-text\">main</code>.</p>\n<p>В Go, как и в другиз языках, точкой входа является <code class=\"language-text\">main()</code> функция. Когда приложения запускается, это первая выполняемая функция и оченьзаманчиво поместить в эту функцию все основные функции приложения. Вместо того, чтобы поместить весь код в <code class=\"language-text\">main</code> пакет, лучшим решением будет создать <code class=\"language-text\">app</code> пакет.</p>\n<p>Размещение основной логики приложения в собственном пакете дает несколько преимуществ. Мне больше всего нравится то, как это упрощает тестирование. Обычно для <code class=\"language-text\">app</code> пакета создаются функции <code class=\"language-text\">Start()</code> и <code class=\"language-text\">Stop()</code> или <code class=\"language-text\">Shutdown()</code>. При создании тестов наличие возможности запускать и останавливать основные функции приложения значительно упрощает написание тестов, которые выполняются в соответствии с основной логикой.</p>\n<p>Ниже показан пример стуктуры пакета <code class=\"language-text\">app</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> app\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span>\n\t<span class=\"token string\">\"fmt\"</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">var</span> ErrShutdown <span class=\"token operator\">=</span> fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Errorf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"application was shutdown gracefully\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">Start</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">error</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// Application runtime code goes here</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">Shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// Shutdown contexts, listeners, and such</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Вышеупомянутое является отличной рекомендацией при создании консольного приложения, которое является одновременно сервером и консольной утилитой (CLI). Вынося основной код в общий пакет, сервер и CLI смогут совместно исползовать пакет <code class=\"language-text\">app</code>.</p>\n<p>Однако, данная рекомендация не отностится к очень простым CLI. Такие утилиты только запускаются, выполняют простые действия и завершают работу. Но даже для простых приложений мне нравится следовать рекомендации и создавать пакет <code class=\"language-text\">app</code>. Это упророщает групировку логики, что снижает барьеры для поддержания кодовой базы.</p>\n<h2>Что тогда делает пакет main?</h2>\n<p><strong>WIP…</strong></p>\n<hr>\n<p><strong>Оригинал:</strong> <a href=\"https://bencane.com/2020/12/29/how-to-structure-a-golang-cli-project/\">How to Structure a Go Command-Line Project</a></p>\n<hr>\n<p>wholly - полностью<br>\nwrite down - записываю<br>\neven - четный / даже<br>\n… as I go. - … по ходу.<br>\nvery tempting - очень заманчиво<br>\nRather than - Вместо того / Скорее, чем<br>\nadvantages - преимущества  </p>","fields":{"readingTime":{"minutes":2.75}},"frontmatter":{"title":"Как структурировать Go CLI проект","date":"02 января 2021","img":{"childImageSharp":{"fluid":{"src":"/static/c11a4921509327d0db6ccb730b7ea7cd/54845/preview.jpg"}}}}}},"pageContext":{"slug":"/2021/how-to-structure-a-golang-cli-project/","previous":{"fields":{"slug":"/improving-obfuscator/"},"frontmatter":{"title":"Улучшение JavaScript обфускатора"}},"next":null}},"staticQueryHashes":["63159454"]}